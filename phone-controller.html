<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Phone Controller - Debug Mode</title>
    <style>
        :root {
            --user-hue: 0;
            --bg-color: hsl(var(--user-hue), 70%, 50%);
            --text-color: white;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            overflow-x: hidden;
            overflow-y: auto;
            padding: 1rem;
            transition: background 0.3s ease;
        }

        #status {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #info {
            background: rgba(0,0,0,0.2);
            padding: 1.5rem;
            border-radius: 1rem;
            width: 100%;
            max-width: 400px;
            backdrop-filter: blur(10px);
            margin-bottom: 1rem;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        .data-label {
            opacity: 0.9;
        }

        .data-value {
            font-weight: bold;
            font-family: monospace;
            min-width: 80px;
            text-align: right;
        }

        #touch-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .touch-point {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255,255,255,0.6);
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: pulse 0.5s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.6; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        button {
            margin: 0.5rem 0;
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            border: none;
            border-radius: 0.5rem;
            background: rgba(0,0,0,0.3);
            color: white;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:active {
            background: rgba(0,0,0,0.5);
        }

        button:disabled {
            background: rgba(0,0,0,0.1);
            opacity: 0.5;
        }

        .permission-btn {
            background: rgba(255,140,0,0.8);
        }

        .permission-btn:active {
            background: rgba(255,140,0,1);
        }

        .hidden {
            display: none !important;
        }

        #error {
            background: rgba(255,0,0,0.3);
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 0.5rem 0;
            text-align: center;
            font-size: 0.9rem;
        }

        #debug {
            background: rgba(0,0,0,0.4);
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 0.5rem 0;
            font-size: 0.8rem;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }

        #device-id {
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
            margin: 1rem 0;
        }

        .section {
            margin: 1rem 0;
        }

        .section h3 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div id="status">READY TO CONNECT</div>
    
    <div id="info">
        <!-- Connection Section -->
        <div id="connection-section" class="section">
            <h3>Connection</h3>
            <button id="connect-btn">CONNECT TO SHOW</button>
            <div id="device-id"></div>
        </div>
        
        <!-- Permissions Section -->
        <div id="permissions-section" class="section hidden">
            <h3>Device Permissions</h3>
            <button id="motion-btn" class="permission-btn">Enable Motion Sensors</button>
            <div class="data-row">
                <span class="data-label">Motion Support:</span>
                <span class="data-value" id="motion-support">checking...</span>
            </div>
        </div>
        
        <!-- Sensor Data Section -->
        <div id="sensor-section" class="section hidden">
            <h3>Sensor Data</h3>
            <div class="data-row">
                <span class="data-label">Tilt X:</span>
                <span class="data-value" id="tilt-x">0°</span>
            </div>
            <div class="data-row">
                <span class="data-label">Tilt Y:</span>
                <span class="data-value" id="tilt-y">0°</span>
            </div>
            <div class="data-row">
                <span class="data-label">Rotate:</span>
                <span class="data-value" id="rotate">0°</span>
            </div>
            <div class="data-row">
                <span class="data-label">Touch:</span>
                <span class="data-value" id="touch-pos">none</span>
            </div>
            <div class="data-row">
                <span class="data-label">Messages Sent:</span>
                <span class="data-value" id="msg-count">0</span>
            </div>
        </div>
        
        <div id="error" class="hidden"></div>
    </div>
    
    <!-- Debug Log -->
    <div id="debug"></div>
    
    <div id="touch-area"></div>

    <script>
        // Generate unique color and device ID
        const userHue = Date.now() % 360;
        const deviceId = `user-${Math.floor(Math.random() * 1000)}-${Date.now().toString(36).slice(-4)}`;
        
        document.documentElement.style.setProperty('--user-hue', userHue);
        document.getElementById('device-id').textContent = `Device: ${deviceId}`;
        
        let socket = null;
        let lastData = {};
        let messageCount = 0;
        let motionGranted = false;
        
        // UI Elements
        const statusEl = document.getElementById('status');
        const connectBtn = document.getElementById('connect-btn');
        const motionBtn = document.getElementById('motion-btn');
        const connectionSection = document.getElementById('connection-section');
        const permissionsSection = document.getElementById('permissions-section');
        const sensorSection = document.getElementById('sensor-section');
        const errorEl = document.getElementById('error');
        const debugEl = document.getElementById('debug');
        
        // Debug logging
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            console.log(logEntry);
            
            const div = document.createElement('div');
            div.textContent = logEntry;
            div.style.color = type === 'error' ? '#ff6b6b' : type === 'warn' ? '#ffa500' : '#4ecdc4';
            debugEl.appendChild(div);
            debugEl.scrollTop = debugEl.scrollHeight;
            
            // Keep only last 20 entries
            while (debugEl.children.length > 20) {
                debugEl.removeChild(debugEl.firstChild);
            }
        }
        
        // Check device capabilities on load
        function checkDeviceCapabilities() {
            debugLog(`User Agent: ${navigator.userAgent}`);
            debugLog(`Device Pixel Ratio: ${window.devicePixelRatio}`);
            debugLog(`Screen: ${screen.width}x${screen.height}`);
            
            if (typeof DeviceOrientationEvent !== 'undefined') {
                debugLog('DeviceOrientationEvent supported');
                document.getElementById('motion-support').textContent = 'Available';
                
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    debugLog('iOS 13+ permission model detected');
                    document.getElementById('motion-support').textContent = 'iOS - Needs Permission';
                } else {
                    debugLog('Auto-grant permission model');
                    document.getElementById('motion-support').textContent = 'Auto-enabled';
                }
            } else {
                debugLog('DeviceOrientationEvent NOT supported', 'warn');
                document.getElementById('motion-support').textContent = 'Not Available';
            }
            
            // Check if we're in a secure context
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                debugLog('WARNING: Not in secure context - sensors may not work', 'warn');
            }
        }
        
        // Auto-detect WebSocket URL
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}`;
        debugLog(`WebSocket URL: ${wsUrl}`);
        
        // Connect button handler
        connectBtn.addEventListener('click', connect);
        motionBtn.addEventListener('click', requestMotionPermission);
        
        function connect() {
            debugLog('Attempting to connect...');
            statusEl.textContent = 'CONNECTING...';
            errorEl.classList.add('hidden');
            
            try {
                socket = new WebSocket(wsUrl);
                
                socket.onopen = () => {
                    debugLog('WebSocket connected successfully');
                    statusEl.textContent = 'CONNECTED';
                    connectionSection.classList.add('hidden');
                    permissionsSection.classList.remove('hidden');
                    
                    // Send initial handshake
                    sendData({
                        type: 'connect',
                        deviceId: deviceId,
                        color: userHue
                    });
                    
                    debugLog(`Sent connect message: ${deviceId}, color: ${userHue}`);
                };
                
                socket.onmessage = (event) => {
                    debugLog(`Received: ${event.data}`);
                    try {
                        const message = JSON.parse(event.data);
                        if (message.type === 'ping') {
                            debugLog(`Server ping: ${message.message}`);
                        }
                    } catch (e) {
                        debugLog(`Non-JSON message: ${event.data}`);
                    }
                };
                
                socket.onclose = (event) => {
                    debugLog(`WebSocket closed: code ${event.code}, reason: ${event.reason}`);
                    statusEl.textContent = 'DISCONNECTED';
                    connectionSection.classList.remove('hidden');
                    permissionsSection.classList.add('hidden');
                    sensorSection.classList.add('hidden');
                    socket = null;
                    
                    // Auto-reconnect after 3 seconds
                    setTimeout(() => {
                        if (!socket) {
                            debugLog('Auto-reconnecting...');
                            connect();
                        }
                    }, 3000);
                };
                
                socket.onerror = (error) => {
                    debugLog(`WebSocket error: ${error}`, 'error');
                    showError('Connection failed. Retrying...');
                    statusEl.textContent = 'CONNECTION ERROR';
                };
                
            } catch (error) {
                debugLog(`Connection error: ${error.message}`, 'error');
                showError('Connection error: ' + error.message);
                statusEl.textContent = 'ERROR';
            }
        }
        
        async function requestMotionPermission() {
            debugLog('Requesting motion permission...');
            
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    debugLog(`Motion permission response: ${response}`);
                    
                    if (response === 'granted') {
                        motionGranted = true;
                        debugLog('Motion permission granted!');
                        startSensors();
                        permissionsSection.classList.add('hidden');
                        sensorSection.classList.remove('hidden');
                    } else {
                        debugLog('Motion permission denied', 'warn');
                        showError('Motion permission denied. Some features won\'t work.');
                        // Still show sensor section for touch
                        sensorSection.classList.remove('hidden');
                    }
                } catch (error) {
                    debugLog(`Permission request failed: ${error.message}`, 'error');
                    showError('Permission request failed: ' + error.message);
                }
            } else {
                debugLog('No permission needed, starting sensors');
                motionGranted = true;
                startSensors();
                permissionsSection.classList.add('hidden');
                sensorSection.classList.remove('hidden');
            }
        }
        
        function showError(message) {
            debugLog(`Error: ${message}`, 'error');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => {
                errorEl.classList.add('hidden');
            }, 5000);
        }
        
        function sendData(data) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const payload = {
                    ...data,
                    deviceId: deviceId,
                    timestamp: Date.now()
                };
                socket.send(JSON.stringify(payload));
                messageCount++;
                document.getElementById('msg-count').textContent = messageCount;
                debugLog(`Sent ${data.type}: ${JSON.stringify(data)}`);
            } else {
                debugLog(`Cannot send data - socket state: ${socket ? socket.readyState : 'null'}`, 'warn');
            }
        }
        
        function startSensors() {
            debugLog('Starting sensors...');
            
            // Start orientation if granted
            if (motionGranted) {
                debugLog('Adding orientation listener');
                window.addEventListener('deviceorientation', handleOrientation);
            }
            
            // Touch events (always available)
            debugLog('Adding touch listeners');
            document.addEventListener('touchstart', handleTouch);
            document.addEventListener('touchmove', handleTouch);
            document.addEventListener('touchend', handleTouchEnd);
            
            // Test orientation immediately
            if (motionGranted) {
                setTimeout(() => {
                    debugLog('Testing orientation data...');
                }, 1000);
            }
        }
        
        function handleOrientation(e) {
            const tiltX = Math.round(e.beta || 0);  // -180 to 180
            const tiltY = Math.round(e.gamma || 0); // -90 to 90
            const rotate = Math.round(e.alpha || 0); // 0 to 360
            
            // Update display
            document.getElementById('tilt-x').textContent = `${tiltX}°`;
            document.getElementById('tilt-y').textContent = `${tiltY}°`;
            document.getElementById('rotate').textContent = `${rotate}°`;
            
            // Only send if changed significantly
            if (Math.abs((lastData.tiltX || 0) - tiltX) > 2 || 
                Math.abs((lastData.tiltY || 0) - tiltY) > 2 || 
                Math.abs((lastData.rotate || 0) - rotate) > 2) {
                
                lastData = { tiltX, tiltY, rotate };
                sendData({
                    type: 'orientation',
                    tiltX: tiltX,
                    tiltY: tiltY,
                    rotate: rotate
                });
            }
        }
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX / window.innerWidth;
            const y = touch.clientY / window.innerHeight;
            
            // Update display
            document.getElementById('touch-pos').textContent = 
                `${Math.round(x * 100)}%, ${Math.round(y * 100)}%`;
            
            // Visual feedback
            const point = document.createElement('div');
            point.className = 'touch-point';
            point.style.left = touch.clientX + 'px';
            point.style.top = touch.clientY + 'px';
            document.getElementById('touch-area').appendChild(point);
            setTimeout(() => point.remove(), 500);
            
            // Send data
            sendData({
                type: 'touch',
                x: x,
                y: y,
                touches: e.touches.length
            });
        }
        
        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                document.getElementById('touch-pos').textContent = 'none';
                sendData({
                    type: 'touch',
                    x: 0,
                    y: 0,
                    touches: 0
                });
            }
        }
        
        // Initialize on page load
        checkDeviceCapabilities();
        
        // Auto-connect after a short delay
        setTimeout(() => {
            if (!socket) {
                debugLog('Auto-connecting...');
                connect();
            }
        }, 1000);
    </script>
</body>
</html>